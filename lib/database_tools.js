// Generated by CoffeeScript 1.7.1

/*
  backbone-sql.js 0.5.7
  Copyright (c) 2013 Vidigami - https://github.com/vidigami/backbone-sql
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {
  var DatabaseTools, Queue, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('underscore');

  Queue = require('backbone-orm/lib/queue');

  module.exports = DatabaseTools = (function() {
    function DatabaseTools(sync, options) {
      this.sync = sync;
      if (options == null) {
        options = {};
      }
      this.ensureIndex = __bind(this.ensureIndex, this);
      this.dropTable = __bind(this.dropTable, this);
      this.createOrUpdateTable = __bind(this.createOrUpdateTable, this);
      this.ensureSchema = __bind(this.ensureSchema, this);
      this.schema = this.sync.schema;
    }

    DatabaseTools.prototype.resetSchema = function(options, callback) {
      var queue, _ref;
      if (arguments.length === 1) {
        _ref = [options, {}], callback = _ref[0], options = _ref[1];
      }
      if (this.resetting) {
        return callback();
      }
      this.resetting = true;
      queue = new Queue();
      queue.defer((function(_this) {
        return function(callback) {
          return _this.dropTable(options, callback);
        };
      })(this));
      queue.defer((function(_this) {
        return function(callback) {
          var join_queue, join_table, _fn, _i, _len, _ref1;
          join_queue = new Queue(1);
          _ref1 = _this.schema.joinTables();
          _fn = function(join_table) {
            return join_queue.defer(function(callback) {
              return join_table.db().resetSchema(callback);
            });
          };
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            join_table = _ref1[_i];
            _fn(join_table);
          }
          return join_queue.await(callback);
        };
      })(this));
      return queue.await((function(_this) {
        return function(err) {
          _this.resetting = false;
          if (err) {
            return callback(err);
          }
          return _this.ensureSchema(options, callback);
        };
      })(this));
    };

    DatabaseTools.prototype.ensureSchema = function(options, callback) {
      var queue, _ref;
      if (arguments.length === 1) {
        _ref = [options, {}], callback = _ref[0], options = _ref[1];
      }
      if (this.ensuring) {
        return callback();
      }
      this.ensuring = true;
      queue = new Queue(1);
      queue.defer((function(_this) {
        return function(callback) {
          return _this.createOrUpdateTable(options, callback);
        };
      })(this));
      queue.defer((function(_this) {
        return function(callback) {
          var join_queue, join_table, _fn, _i, _len, _ref1;
          join_queue = new Queue(1);
          _ref1 = _this.schema.joinTables();
          _fn = function(join_table) {
            return join_queue.defer(function(callback) {
              return join_table.db().ensureSchema(callback);
            });
          };
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            join_table = _ref1[_i];
            _fn(join_table);
          }
          return join_queue.await(callback);
        };
      })(this));
      return queue.await((function(_this) {
        return function(err) {
          _this.ensuring = false;
          return callback(err);
        };
      })(this));
    };

    DatabaseTools.prototype.createOrUpdateTable = function(options, callback) {
      this.sync.collection((function(_this) {
        return function(err, collection) {
          var field, key, queue, relation, _ref, _ref1;
          if (err) {
            return callback(err);
          }
          if (options.verbose) {
            console.log("Ensuring table: " + collection.collectionName + " with fields: '" + (_.keys(_this.schema.fields).join(', ')) + "' and relations: '" + (_.keys(_this.schema.relations).join(', ')) + "'");
          }
          queue = new Queue();
          queue.defer(function(callback) {
            return _this.ensureIndex(_this.sync.backbone_adapter.id_attribute, options, callback);
          });
          _ref = _this.schema.fields;
          for (key in _ref) {
            field = _ref[key];
            if (field.indexed) {
              (function(key) {
                return queue.defer(function(callback) {
                  return _this.ensureIndex(key, options, callback);
                });
              })(key);
            }
          }
          _ref1 = _this.schema.relations;
          for (key in _ref1) {
            relation = _ref1[key];
            if ((relation.type === 'belongsTo') && !relation.isVirtual() && !relation.isEmbedded()) {
              (function(key, relation) {
                return queue.defer(function(callback) {
                  return _this.ensureIndex(relation.foreign_key, options, callback);
                });
              })(key, relation);
            }
          }
          return queue.await(callback);
        };
      })(this));
    };

    DatabaseTools.prototype.dropTable = function(options, callback) {
      var _ref;
      if (arguments.length === 1) {
        _ref = [options, {}], callback = _ref[0], options = _ref[1];
      }
      return this.sync.collection((function(_this) {
        return function(err, collection) {
          if (err) {
            return callback(err);
          }
          return collection.remove(function(err) {
            if (err) {
              if (options.verbose) {
                console.log("Failed to reset collection: " + collection.collectionName + ". Error: " + err);
              }
            } else {
              if (options.verbose) {
                console.log("Reset collection: " + collection.collectionName);
              }
            }
            return callback(err);
          });
        };
      })(this));
    };

    DatabaseTools.prototype.ensureIndex = function(field_name, options, callback) {
      var index_info, _ref;
      if (arguments.length === 2) {
        _ref = [options, {}], callback = _ref[0], options = _ref[1];
      }
      index_info = {};
      index_info[field_name] = 1;
      return this.sync.collection((function(_this) {
        return function(err, collection) {
          if (err) {
            return callback(err);
          }
          return collection.ensureIndex(index_info, {
            background: true
          }, function(err) {
            if (err) {
              return callback(new Error("MongoBackbone: Failed to indexed '" + field_name + "' on " + collection.collectionName + ". Reason: " + err));
            }
            if (options.verbose) {
              console.log("MongoBackbone: Successfully indexed '" + field_name + "' on " + collection.collectionName);
            }
            return callback();
          });
        };
      })(this));
    };

    return DatabaseTools;

  })();

}).call(this);
