// Generated by CoffeeScript 1.7.1

/*
  backbone-mongo.js 0.5.9
  Copyright (c) 2013 Vidigami - https://github.com/vidigami/backbone-mongo
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {
  var Backbone, Connection, DESTROY_BATCH_LIMIT, DatabaseTools, ModelCache, ModelTypeID, MongoCursor, MongoSync, QueryCache, Queue, Schema, Utils, moment, util, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  util = require('util');

  _ = require('underscore');

  Backbone = require('backbone');

  moment = require('moment');

  Queue = require('backbone-orm/lib/queue');

  Schema = require('backbone-orm/lib/schema');

  Utils = require('backbone-orm/lib/utils');

  QueryCache = require('backbone-orm/lib/cache/singletons').QueryCache;

  ModelCache = require('backbone-orm/lib/cache/singletons').ModelCache;

  ModelTypeID = require('backbone-orm/lib/cache/singletons').ModelTypeID;

  MongoCursor = require('./cursor');

  Connection = require('./connection');

  DatabaseTools = require('./database_tools');

  DESTROY_BATCH_LIMIT = 1000;

  MongoSync = (function() {
    function MongoSync(model_type, sync_options) {
      this.model_type = model_type;
      this.sync_options = sync_options;
      this.db = __bind(this.db, this);
      this.model_type.model_name = Utils.findOrGenerateModelName(this.model_type);
      this.model_type.model_id = ModelTypeID.generate(this.model_type);
      this.schema = new Schema(this.model_type);
      this.backbone_adapter = this.model_type.backbone_adapter = this._selectAdapter();
    }

    MongoSync.prototype.initialize = function(model) {
      var url;
      if (this.is_initialized) {
        return;
      }
      this.is_initialized = true;
      this.schema.initialize();
      if (!(url = _.result(new this.model_type, 'url'))) {
        throw new Error("Missing url for model");
      }
      return this.connect(url);
    };

    MongoSync.prototype.read = function(model, options) {
      if (model.models) {
        return this.cursor().toJSON(function(err, json) {
          if (err) {
            return options.error(err);
          }
          return options.success(json);
        });
      } else {
        return this.cursor(model.id).toJSON(function(err, json) {
          if (err) {
            return options.error(err);
          }
          if (!json) {
            return options.error(new Error("Model not found. Id " + model.id));
          }
          return options.success(json);
        });
      }
    };

    MongoSync.prototype.create = function(model, options) {
      if (this.manual_id && !model.id) {
        return options.error(new Error("Missing manual id for create: " + (util.inspect(model.attributes))));
      }
      return QueryCache.reset(this.model_type, (function(_this) {
        return function(err) {
          if (err) {
            return options.error(err);
          }
          return _this.connection.collection(function(err, collection) {
            var doc;
            if (err) {
              return options.error(err);
            }
            if (model.get('_rev')) {
              return options.error(new Error('New document has a non-empty revision'));
            }
            doc = _this.backbone_adapter.attributesToNative(model.toJSON());
            doc._rev = 1;
            return collection.insert(doc, function(err, docs) {
              if (err || !docs || docs.length !== 1) {
                return options.error(new Error("Failed to create model. Error: " + (err || 'document not found')));
              }
              return options.success(_this.backbone_adapter.nativeToAttributes(docs[0]));
            });
          });
        };
      })(this));
    };

    MongoSync.prototype.update = function(model, options) {
      if (!model.get('_rev')) {
        return this.create(model, options);
      }
      if (this.manual_id && !model.id) {
        return options.error(new Error("Missing manual id for create: " + (util.inspect(model.attributes))));
      }
      return QueryCache.reset(this.model_type, (function(_this) {
        return function(err) {
          if (err) {
            return options.error(err);
          }
          return _this.connection.collection(function(err, collection) {
            var find_query, json, key, modifications, unsets, _i, _len;
            if (err) {
              return options.error(err);
            }
            json = _this.backbone_adapter.attributesToNative(model.toJSON());
            if (_this.backbone_adapter.id_attribute === '_id') {
              delete json._id;
            }
            find_query = _this.backbone_adapter.modelFindQuery(model);
            find_query._rev = json._rev;
            json._rev++;
            modifications = {
              $set: json
            };
            if (unsets = Utils.get(model, 'unsets')) {
              Utils.unset(model, 'unsets');
              if (unsets.length) {
                modifications.$unset = {};
                for (_i = 0, _len = unsets.length; _i < _len; _i++) {
                  key = unsets[_i];
                  if (!model.attributes.hasOwnProperty(key)) {
                    modifications.$unset[key] = '';
                  }
                }
              }
            }
            return collection.findAndModify(find_query, [[_this.backbone_adapter.id_attribute, 'asc']], modifications, {
              "new": true
            }, function(err, doc) {
              if (err) {
                return options.error(new Error("Failed to update model (" + _this.model_type.model_name + "). Error: " + err));
              }
              if (!doc) {
                return options.error(new Error("Failed to update model (" + _this.model_type.model_name + "). Either the document has been deleted or the revision (_rev) was stale."));
              }
              if (doc._rev !== json._rev) {
                return options.error(new Error("Failed to update revision (" + _this.model_type.model_name + "). Is: " + doc._rev + " expecting: " + json._rev));
              }
              return options.success(_this.backbone_adapter.nativeToAttributes(doc));
            });
          });
        };
      })(this));
    };

    MongoSync.prototype["delete"] = function(model, options) {
      return QueryCache.reset(this.model_type, (function(_this) {
        return function(err) {
          if (err) {
            return options.error(err);
          }
          return _this.connection.collection(function(err, collection) {
            if (err) {
              return options.error(err);
            }
            return collection.remove(_this.backbone_adapter.attributesToNative({
              id: model.id
            }), function(err) {
              if (err) {
                return options.error(err);
              }
              return options.success();
            });
          });
        };
      })(this));
    };

    MongoSync.prototype.resetSchema = function(options, callback) {
      return this.db().resetSchema(options, callback);
    };

    MongoSync.prototype.cursor = function(query) {
      if (query == null) {
        query = {};
      }
      return new MongoCursor(query, _.pick(this, ['model_type', 'connection', 'backbone_adapter']));
    };

    MongoSync.prototype.destroy = function(query, callback) {
      return QueryCache.reset(this.model_type, (function(_this) {
        return function(err) {
          if (err) {
            return callback(err);
          }
          return _this.connection.collection(function(err, collection) {
            if (err) {
              return callback(err);
            }
            return _this.model_type.each(_.extend({
              $each: {
                limit: DESTROY_BATCH_LIMIT,
                json: true
              }
            }, query), (function(model_json, callback) {
              return Utils.patchRemoveByJSON(_this.model_type, model_json, function(err) {
                if (err) {
                  return callback(err);
                }
                return collection.remove(_this.backbone_adapter.attributesToNative({
                  id: model_json.id
                }), function(err) {
                  if (err) {
                    return callback(err);
                  }
                  return callback();
                });
              });
            }), callback);
          });
        };
      })(this));
    };

    MongoSync.prototype.connect = function(url) {
      if (this.connection && this.connection.url === url) {
        return;
      }
      if (this.connection) {
        this.connection.destroy();
      }
      return this.connection = new Connection(url, this.schema, this.sync_options.connection_options || {});
    };

    MongoSync.prototype.collection = function(callback) {
      return this.connection.collection(callback);
    };

    MongoSync.prototype.db = function() {
      return this.db_tools || (this.db_tools = new DatabaseTools(this));
    };

    MongoSync.prototype._selectAdapter = function() {
      var field_info, field_name, info, _i, _len, _ref;
      _ref = this.schema.raw;
      for (field_name in _ref) {
        field_info = _ref[field_name];
        if ((field_name !== 'id') || !_.isArray(field_info)) {
          continue;
        }
        for (_i = 0, _len = field_info.length; _i < _len; _i++) {
          info = field_info[_i];
          if (info.manual_id) {
            this.manual_id = true;
            return require('./document_adapter_no_mongo_id');
          }
        }
      }
      return require('./document_adapter_mongo_id');
    };

    return MongoSync;

  })();

  module.exports = function(type, sync_options) {
    var model_type, sync, sync_fn;
    if (sync_options == null) {
      sync_options = {};
    }
    if (Utils.isCollection(new type())) {
      model_type = Utils.configureCollectionModelType(type, module.exports);
      return type.prototype.sync = model_type.prototype.sync;
    }
    sync = new MongoSync(type, sync_options);
    type.prototype.sync = sync_fn = function(method, model, options) {
      if (options == null) {
        options = {};
      }
      sync.initialize();
      if (method === 'createSync') {
        return module.exports.apply(null, Array.prototype.slice.call(arguments, 1));
      }
      if (method === 'sync') {
        return sync;
      }
      if (method === 'schema') {
        return sync.schema;
      }
      if (method === 'isRemote') {
        return false;
      }
      if (sync[method]) {
        return sync[method].apply(sync, Array.prototype.slice.call(arguments, 1));
      } else {
        return void 0;
      }
    };
    require('backbone-orm/lib/extensions/model')(type);
    return ModelCache.configureSync(type, sync_fn);
  };

}).call(this);
