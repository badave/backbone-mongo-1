// Generated by CoffeeScript 1.6.3
/*
  backbone-mongo.js 0.0.1
  Copyright (c) 2013 Vidigami - https://github.com/vidigami/backbone-mongo
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
*/


(function() {
  var CONNECTION_QUERIES, Connection, ConnectionPool, DatabaseUrl, MongoClient, Queue, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('underscore');

  Queue = require('backbone-orm/lib/queue');

  DatabaseUrl = require('backbone-orm/lib/database_url');

  ConnectionPool = require('backbone-orm/lib/connection_pool');

  CONNECTION_QUERIES = require('./connection_queries');

  MongoClient = require('mongodb').MongoClient;

  module.exports = Connection = (function() {
    Connection.options = {};

    function Connection(url, schema, options) {
      var collection_name, connection_options, database_url, key, queue, value, _i, _len, _ref,
        _this = this;
      this.url = url;
      this.schema = schema != null ? schema : {};
      if (options == null) {
        options = {};
      }
      this.ensureIndex = __bind(this.ensureIndex, this);
      if (!_.isString(this.url)) {
        throw new Error('Expecting a string url');
      }
      connection_options = _.extend(_.clone(Connection.options), options);
      this.collection_requests = [];
      this.db = null;
      database_url = new DatabaseUrl(this.url, true);
      collection_name = database_url.table;
      database_url.query || (database_url.query = {});
      delete database_url.search;
      _ref = database_url.query;
      for (key in _ref) {
        value = _ref[key];
        connection_options[key] = value;
      }
      database_url.query = {};
      for (_i = 0, _len = CONNECTION_QUERIES.length; _i < _len; _i++) {
        key = CONNECTION_QUERIES[_i];
        if (connection_options.hasOwnProperty(key)) {
          database_url.query[key] = connection_options[key];
          delete connection_options[key];
        }
      }
      this.url = database_url.format({
        exclude_table: true
      });
      queue = new Queue(1);
      queue.defer(function(callback) {
        if (_this.db = ConnectionPool.get(_this.url)) {
          return callback();
        }
        return MongoClient.connect(_this.url, connection_options, function(err, db) {
          if (err) {
            return callback(err);
          }
          if (_this.db = ConnectionPool.get(_this.url)) {
            db.close();
          } else {
            ConnectionPool.set(_this.url, _this.db = db);
          }
          return callback();
        });
      });
      queue.defer(function(callback) {
        return _this.db.collection(collection_name, function(err, collection) {
          var field, relation, _ref1, _ref2, _results;
          if (!err) {
            _this._collection = collection;
          }
          callback(err);
          _ref1 = _this.schema.fields;
          for (key in _ref1) {
            field = _ref1[key];
            if (field.indexed) {
              _this.ensureIndex(key, collection_name);
            }
          }
          _ref2 = _this.schema.relations;
          _results = [];
          for (key in _ref2) {
            relation = _ref2[key];
            if (relation.type === 'belongsTo' && !relation.isVirtual() && !relation.isEmbedded()) {
              _results.push(_this.ensureIndex(relation.foreign_key, collection_name));
            }
          }
          return _results;
        });
      });
      queue.await(function(err) {
        var collection_requests, request, _j, _k, _len1, _len2, _results, _results1;
        collection_requests = _.clone(_this.collection_requests);
        _this.collection_requests = [];
        if (_this.failed_connection = !!err) {
          console.log("Backbone-Mongo: unable to create connection. Error: " + err);
          _results = [];
          for (_j = 0, _len1 = collection_requests.length; _j < _len1; _j++) {
            request = collection_requests[_j];
            _results.push(request(new Error('Connection failed')));
          }
          return _results;
        } else {
          _results1 = [];
          for (_k = 0, _len2 = collection_requests.length; _k < _len2; _k++) {
            request = collection_requests[_k];
            _results1.push(request(null, _this._collection));
          }
          return _results1;
        }
      });
    }

    Connection.prototype.destroy = function() {
      var collection_requests, request, _i, _len;
      if (!this.db) {
        return;
      }
      collection_requests = _.clone(this.collection_requests);
      this.collection_requests = [];
      for (_i = 0, _len = collection_requests.length; _i < _len; _i++) {
        request = collection_requests[_i];
        request(new Error('Client closed'));
      }
      this._collection = null;
      this.db.close();
      return this.db = null;
    };

    Connection.prototype.collection = function(callback) {
      if (this.failed_connection) {
        return callback(new Error('Connection failed'));
      }
      if (this._collection) {
        return callback(null, this._collection);
      }
      return this.collection_requests.push(callback);
    };

    Connection.prototype.ensureIndex = function(field_name, table_name) {
      var index_info,
        _this = this;
      index_info = {};
      index_info[field_name] = 1;
      return this._collection.ensureIndex(index_info, {
        background: true
      }, function(err) {
        if (err) {
          return new Error("MongoBackbone: Failed to indexed '" + field_name + "' on " + table_name + ". Reason: " + err);
        }
        return console.log("MongoBackbone: Successfully indexed '" + field_name + "' on " + table_name);
      });
    };

    return Connection;

  })();

}).call(this);
